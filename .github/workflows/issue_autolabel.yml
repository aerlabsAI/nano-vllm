name: Label issues based on keywords
on:
  issues:
    types: [opened, edited, reopened, assigned, unassigned]
permissions:
  issues: write
  contents: read
concurrency:
  group: issue-labeler-${{ github.event.issue.number }}
  cancel-in-progress: true
jobs:
  add-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Label issues based on keywords
        id: label-step
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        with:
          script: |
            // Configuration: Add new labels and keywords here
            const labelConfig = {
              "ðŸ“‘ PagedAttention": {
                keywords: [
                  { term: "paged attention", searchIn: "both" },
                  { term: "pagedattention", searchIn: "both" },
                  { term: "kv cache", searchIn: "both" },
                  { term: "block table", searchIn: "both" },
                  { term: "memory management", searchIn: "both" }
                ],
                substrings: [
                  { term: "paged", searchIn: "title" }
                ]
              },
              "ðŸŒ Continuous Batching": {
                keywords: [
                  { term: "continuous batching", searchIn: "both" },
                  { term: "dynamic batching", searchIn: "both" },
                  { term: "scheduler", searchIn: "both" },
                  { term: "request management", searchIn: "both" }
                ],
                substrings: [
                  { term: "batch", searchIn: "both" }
                ]
              },
              "â›½ï¸ Chunked Prefill": {
                keywords: [
                  { term: "chunked prefill", searchIn: "both" },
                  { term: "prefill", searchIn: "both" }
                ],
                substrings: [
                  { term: "chunk", searchIn: "both" }
                ]
              },
              "âš™ï¸ CUDA": {
                keywords: [
                  { term: "cuda", searchIn: "both" },
                  { term: "gpu", searchIn: "both" }
                ],
                substrings: [
                  { term: ".cu", searchIn: "body" },
                  { term: ".cuh", searchIn: "body" }
                ]
              },
              "âš™ï¸ C++": {
                keywords: [
                  { term: "c++", searchIn: "both" },
                  { term: "cpp", searchIn: "both" }
                ],
                substrings: [
                  { term: ".cpp", searchIn: "body" },
                  { term: ".hpp", searchIn: "body" },
                  { term: ".h", searchIn: "body" }
                ]
              },
              "ðŸ’¿ CI": {
                keywords: [
                  { term: "ci", searchIn: "both" },
                  { term: "continuous integration", searchIn: "both" },
                  { term: "github actions", searchIn: "both" },
                  { term: "workflow", searchIn: "both" },
                  { term: "pre-commit", searchIn: "both" }
                ],
                substrings: [
                  { term: ".github/workflows", searchIn: "body" },
                  { term: "pre-commit-config", searchIn: "body" }
                ]
              }
            };

            // Helper function to create regex based on search type
            function createSearchRegex(term, type) {
              const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              switch (type) {
                case 'keyword':
                  return new RegExp(`\\b${escapedTerm}\\b`, "gi");
                case 'substring':
                  return new RegExp(escapedTerm, "gi");
                default:
                  throw new Error(`Unknown search type: ${type}`);
              }
            }

            // Helper function to find matching terms in text with line information
            function findMatchingTermsWithLines(text, searchTerms = [], searchType = 'keyword', searchLocation = '') {
              const matches = [];
              const lines = text.split('\n');

              for (const termConfig of searchTerms) {
                let regex;
                let term, searchIn, pattern, description, flags;

                if (typeof termConfig === 'string') {
                  term = termConfig;
                  searchIn = 'both';
                } else {
                  term = termConfig.term;
                  searchIn = termConfig.searchIn || 'both';
                  pattern = termConfig.pattern;
                  description = termConfig.description;
                  flags = termConfig.flags;
                }

                if (searchIn !== 'both' && searchIn !== searchLocation) {
                  continue;
                }

                if (searchType === 'regex') {
                  regex = new RegExp(pattern, flags || "gi");
                } else {
                  regex = createSearchRegex(term, searchType);
                }

                const termMatches = [];

                lines.forEach((line, lineIndex) => {
                  const lineMatches = line.match(regex);
                  if (lineMatches) {
                    lineMatches.forEach(match => {
                      termMatches.push({
                        match: match,
                        lineNumber: lineIndex + 1,
                        lineContent: line.trim(),
                        searchType: searchType,
                        searchLocation: searchLocation,
                        originalTerm: term || pattern,
                        description: description,
                        context: line.length > 100 ?
                          line.substring(Math.max(0, line.toLowerCase().indexOf(match.toLowerCase()) - 30),
                                       line.toLowerCase().indexOf(match.toLowerCase()) + match.length + 30) + '...'
                          : line.trim()
                      });
                    });
                  }
                });

                if (termMatches.length > 0) {
                  matches.push({
                    term: term || (description || pattern),
                    searchType: searchType,
                    searchLocation: searchLocation,
                    searchIn: searchIn,
                    pattern: pattern,
                    matches: termMatches,
                    count: termMatches.length
                  });
                }
              }

              return matches;
            }

            // Helper function to check if label should be added
            async function processLabel(labelName, config) {
              const body = context.payload.issue.body || "";
              const title = context.payload.issue.title || "";
              // Remove HTML comments to avoid matching example text in issue template
              const cleanedBody = body.replace(/<!--[\s\S]*?-->/g, '');

              core.notice(`Processing label: ${labelName}`);
              core.notice(`Issue Title: "${title}"`);
              core.notice(`Issue Body length: ${body.length} characters (${cleanedBody.length} after removing HTML comments)`);

              let allMatches = [];
              const keywords = config.keywords || [];
              const substrings = config.substrings || [];
              const regexPatterns = config.regexPatterns || [];

              core.notice(`Searching with ${keywords.length} keywords, ${substrings.length} substrings, and ${regexPatterns.length} regex patterns`);

              // Search in title
              if (title.trim()) {
                core.notice(`Searching in title: "${title}"`);
                const titleKeywordMatches = findMatchingTermsWithLines(title, keywords, 'keyword', 'title');
                const titleSubstringMatches = findMatchingTermsWithLines(title, substrings, 'substring', 'title');
                const titleRegexMatches = findMatchingTermsWithLines(title, regexPatterns, 'regex', 'title');
                allMatches.push(...titleKeywordMatches, ...titleSubstringMatches, ...titleRegexMatches);
              }

              // Search in body
              if (cleanedBody.trim()) {
                core.notice(`Searching in cleaned body (${cleanedBody.length} characters)`);
                const bodyKeywordMatches = findMatchingTermsWithLines(cleanedBody, keywords, 'keyword', 'body');
                const bodySubstringMatches = findMatchingTermsWithLines(cleanedBody, substrings, 'substring', 'body');
                const bodyRegexMatches = findMatchingTermsWithLines(cleanedBody, regexPatterns, 'regex', 'body');
                allMatches.push(...bodyKeywordMatches, ...bodySubstringMatches, ...bodyRegexMatches);
              }

              if (allMatches.length > 0) {
                core.notice(`Found ${allMatches.length} matching term(s) for label "${labelName}"`);

                // Check if label exists in repository
                const { data: repoLabels } = await github.rest.issues.listLabelsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
                const repoLabelNames = repoLabels.map(l => l.name);

                if (!repoLabelNames.includes(labelName)) {
                  core.setFailed(`Label "${labelName}" does not exist in repository. Please create it first.`);
                  return { added: false, matched: false };
                }

                const existingLabels = context.payload.issue.labels.map(l => l.name);
                if (!existingLabels.includes(labelName)) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: [labelName],
                  });
                  core.notice(`Label "${labelName}" added.`);
                  return { added: true, matched: true };
                }
                core.notice(`Label "${labelName}" already present.`);
                return { added: false, matched: true };
              }

              core.notice(`No matching terms found for label "${labelName}".`);
              return { added: false, matched: false };
            }

            // Process all configured labels
            const labelsResults = await Promise.all(
              Object.entries(labelConfig).map(([labelName, config]) =>
                processLabel(labelName, config).then(result => ({ labelName, ...result }))
              )
            );

            // Get current labels to check for removal
            const existingLabels = context.payload.issue.labels.map(l => l.name);
            const allConfiguredLabels = Object.keys(labelConfig);
            const matchedLabels = labelsResults.filter(r => r.matched).map(r => r.labelName);

            // Remove labels that are no longer relevant
            const labelsToRemove = existingLabels.filter(
              label => allConfiguredLabels.includes(label) && !matchedLabels.includes(label)
            );

            for (const labelToRemove of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: labelToRemove
              });
              core.notice(`Removed label "${labelToRemove}" - no longer matches issue`);
            }

            core.notice(`Keyword-based processing complete. Added: ${labelsResults.filter(r => r.added).length}, Removed: ${labelsToRemove.length}`);

            // Assignee-based labeling
            const assigneeLabels = {
              "RRoundTable": "ðŸ«‚ Group 1",
              "Zerohertz": "ðŸ«‚ Group 1",
              "loveysuby": "ðŸ«‚ Group 2",
              "teddygood": "ðŸ«‚ Group 2"
            };
            
            const assignees = context.payload.issue.assignees || [];
            const assignedUsernames = assignees.map(a => a.login);
            
            // Check if assignee labels exist in repository
            const { data: repoLabels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const repoLabelNames = repoLabels.map(l => l.name);
            
            const allGroupLabels = [...new Set(Object.values(assigneeLabels))];
            for (const groupLabel of allGroupLabels) {
              if (!repoLabelNames.includes(groupLabel)) {
                core.setFailed(`Label "${groupLabel}" does not exist in repository. Please create it first.`);
                return;
              }
            }
            
            // Add labels for current assignees
            for (const assignee of assignees) {
              const username = assignee.login;
              if (assigneeLabels[username]) {
                const labelToAdd = assigneeLabels[username];
                
                if (!existingLabels.includes(labelToAdd)) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: [labelToAdd],
                  });
                  core.notice(`Added label "${labelToAdd}" based on assignee @${username}`);
                }
              }
            }
            
            // Remove labels for unassigned users
            const activeGroupLabels = [...new Set(assignedUsernames.map(u => assigneeLabels[u]).filter(Boolean))];
            const assigneeLabelsToRemove = allGroupLabels.filter(label =>
              existingLabels.includes(label) && !activeGroupLabels.includes(label)
            );

            for (const labelToRemove of assigneeLabelsToRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: labelToRemove
              });
              core.notice(`Removed label "${labelToRemove}" - no assignees from this group`);
            }
            
            const numLabelsAdded = labelsResults.filter(r => r.added).length;
            core.notice(`Overall processing complete. ${numLabelsAdded} label(s) added from keywords.`);

            const addedLabels = labelsResults.filter(r => r.added).map(r => r.labelName);
            core.setOutput('labels_added', JSON.stringify(addedLabels));
            return addedLabels;
